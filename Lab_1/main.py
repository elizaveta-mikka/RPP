import random


def cr_list(ls1, ls2):  # Метод, ковертирующий строковые элементы в целочисленные.
    # Так как заранее было проверено, если в списках элементы, которые могут ковертироваться некорретно, данный метод не вызовет ошибки
    a = [int(item) for item in
         ls1]  # Строковые элементы конвертируются в целочисленные, полученный список А возвращается
    b = [int(item) for item in
         ls2]  # Строковые элементы конвертируются в целочисленные, полученный список B возвращается
    return a, b


def new_list(alist, blist, i_a, i_b, max_a, max_b, name):  # Создание нового списка и его отображение
    alist[i_a - max_a + 1:i_a + 1] = blist[
                                     i_b - max_b + 1:i_b + 1]  # Максимальная последовательность из списка blist встаёт на место макс. последовательности списка alist
    print("\nСписок " + name + " после алгоритма:")  # Отображение результата
    for i in range(len(alist)):
        print(alist[i], end=" ")


def even_subseq_1_2(alist):  # Выполнение заданного алгоритма с использованием стандартных функций списков. Метод 2
    seq = []  # В список будут записываться длины четных цепочек
    i_list = 0  # Номер элемента, в котором заканчивается строка максимальной длины
    if alist[0] % 2 == 0:
        seq.append(
            1)  # Если первый элемент списка четный, тот длина четной последовательности - 1. Это число и записывается в seq
    else:
        seq.append(
            0)  # Первый элемент списка нечетный, значит на "момент" первого элемента списка длина четный последовательности - 0. Число нечетно
    for i in range(1, len(alist)):  # Рассматриваются остальные элементы списка
        if alist[i] % 2 == 0:
            seq.append(seq[i - 1] + 1)  # Если число - четное, то к последнему значению из списка seq прибавляется 1
            if max(seq) == seq[
                i]:  # Если получившееся число (см. выше), является максимальным в списке, то i_list становится равным i
                i_list = i
        else:
            seq.append(0)  # Если число нечетное - 0. Нужна четная последовательность
    return seq, i_list


def even_subseq_1(a, b):  # Выполнение заданного алгоритма с использованием стандартных функций списков. Метод 1
    seq_a, i_a = even_subseq_1_2(a)  # Список длин четных последовательностей списка A
    seq_b, i_b = even_subseq_1_2(b)  # Список длин четных последовательностей списка B
    max_a = max(seq_a)  # Поиск максимального элемента в списке длин длин четных последовательностей списка A
    max_b = max(seq_b)  # Поиск максимального элемента в списке длин длин четных последовательностей списка B
    c = b.copy()  # Новые списки для новых списков
    d = a.copy()
    new_list(d, b, i_a, i_b, max_a, max_b, "А")  # Создание новых списков и их вывод пользователю
    new_list(c, a, i_b, i_a, max_b, max_a, "B")


def my_lists_len(lt):  # Метод для нахждения длины списка
    k = 0
    for i in lt:  # При переходе к следующими элементу списка, количество увеличивается на 1
        k += 1
    return k  # Длина спсика возвращается


def my_lists_max(lt):  # Метод для поиска максимального числа в seq
    max = -1000
    for i in lt:  # Перебором находится наибольшее число в списке четных последовательностей
        if max < i:
            max = i
    return max


def my_lists_copy(lt):  # Метод, копирующий один список в другой
    lt1 = [0] * my_lists_len(
        lt)  # Создаётся новый список, который равен по длине переданному списку и заполняется нулями
    for i in range(my_lists_len(
            lt)):  # Соответствующему элементу нового списка присваивается значение соответствующегося элемента переданного списка
        lt1[i] = lt[i]
    return lt1


def even_subseq_2_2(alist):  # Выполнение заданного алгоритма без использования стандартных функций списков. Метод 2
    l_alist = my_lists_len(alist)  # Длина переданного списка
    seq = [0] * l_alist  # Список длины l_alist заполянется нулями
    # Следующий код программы выполняет все те же действия что и метод even_subseq_1_2.
    # Добавление в список seq происходит в данном методе с помощью присваивания нового значения для каждого элемента списка (что отличны от 0)
    i_list = 0
    if alist[0] % 2 == 0:
        seq[0] = 1
    for i in range(1, l_alist):
        if alist[i] % 2 == 0:
            seq[i] = seq[i - 1] + 1
            if my_lists_max(seq) == seq[i]:
                i_list = i
        else:
            seq[i] = 0
    return seq, i_list


def even_subseq_2(a, b):  # Выполнение заданного алгоритма без использования стандартных функций списков. Метод 1
    # Данный метод аналогичен методу even_subseq_1, с той только разницей, что некоторые методы созданы в программе самостоятельно
    seq_a, i_a = even_subseq_2_2(a)
    seq_b, i_b = even_subseq_2_2(b)
    max_a = my_lists_max(seq_a)
    max_b = my_lists_max(seq_b)
    c = my_lists_copy(b)
    d = my_lists_copy(a)
    new_list(d, b, i_a, i_b, max_a, max_b, "А")
    new_list(c, a, i_b, i_a, max_b, max_a, "B")


def ex_list(str, name):  # Метод, проверяющий список на пустоту
    if s1 == '':  # Если пользователь ничего не ввёл, дальнейшая работа со списками невозможна
        print("Список A не введён! Алгоритм не может быть выполнен!")
        return False
    return True


def correct_list(list,
                 name):  # Метод, проверяющий возможно ли конвертировать каждый элемент списка в целочисленную перемнную
    for i in range(len(list)):
        try:
            int(list[i])  # i-ый элемент конвертируется в целочисленное значение
        except ValueError:  # Если возникает данная ошибка, ввод некорректен. Дальнейшие действия со списками невозможны
            print("Список " + name + " некорректен!")
            return False
    return True


def cr_auto_gen():  # Метод автоматической генерации
    s = ''  # В данную пустую строку будут записываться элементы будущего списка
    l = random.randint(1, 30)  # Генерация длины списка
    for i in range(l):
        s += str(random.randint(-100, 100)) + ' '  # Генерация элементов списка и запись их в строку
    print(s)
    return s


print("Формирование элементов списка будет осущевляться следующим образом:\n"
      "1. Ввод через клавиатуру\n"
      "2. Автоматическая генерация")
an = int(input())  # Выбор пользователя
if an == 1:  # Ввод с клавиатуры
    print("Список А:")
    s1 = str(input())  # Строка А, используется для получения списка А
    print("Список B:")
    s2 = str(input())  # Строка В, используется для получения списка В
if an == 2:  # Автоматическая генерация
    print("Список А:")
    s1 = cr_auto_gen()  # Метод автоматической генерации
    print("Список B:")
    s2 = cr_auto_gen()
if an != 1 and an != 2:  # Сделанный пользователь выбор - некорректен
    print("Выберите один из вариантов формирования списков!")
else:  # Сторки списков сформированы
    if ex_list(s1, "A") and ex_list(s2, "B"):  # Проверка на пустоту списка
        a_ = s1.split()  # Формирование списка. Строка делится по пробелам на отдельные строковые элементы
        b_ = s2.split()
        if correct_list(a_, "А") and correct_list(b_, "B"):  # Проверка списка на наличие некорректных символов
            a, b = cr_list(a_, b_)  # Создаются списки с целочисленными элементами
            print(
                "\nПервый вариант реализации заданного алгоритма:")  # Алгоритм с использованием стандартных функций списков
            even_subseq_1(a, b)  # Результат работы алгоритма строкой выше
            print(
                "\n\nВторой вариант реализации заданного алгоритма:")  # Алгоритм без использования стандартных функций списков
            even_subseq_2(a, b)  # Результат работы алгоритма строкой выше
